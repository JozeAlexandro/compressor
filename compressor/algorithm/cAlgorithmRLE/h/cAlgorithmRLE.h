/** ****************************************************************************
 * \file cAlgorithmRLE.h
 *
 * \defgroup AlgorithmRLE Алгоритм RLE
 * @{
 *
 * \ingroup Algorithm
 *
 * \brief Модуль, реализующий алгоритм RLE
 *
 * \details
 * Реализация алгоритма:
 * Для реализации алгоритма необходимо хранить количество повторяемых символов
 * и, непосредственно, однобайтные коды этих символов. Принято решение:
 * создать служебный байт и использовать его для хранения этой информации.
 *
 * Последовательности символов делим на 2 вида: последовательность одинаковых
 * элементов, наприммер, 0xAA 0xAA 0xAA и последовательность разных элементов,
 * например 0xAB 0x12. В служебной байте необходимо определить тип
 * последовательности и ее длину.
 *
 * Старший бит служебного байта отводится для определения типа
 * последовательности. Остальные 7 бит отвечают за количество символов.
 *
 * Если старший бит = 1 - то оставшиеся 7 бит кодируют количество элементов,
 * равных значению следующего байта, например:
 * Исходные данные [ 0x01 0x01 0x01 ] - т.к. это цепочка элементов, выставляем
 * старший бит в 1, а в остальных битах кодируем количество повторов = 3 = 11b.
 * Тогда служебный байт = [ 1 0 0 0  0 0 1 1 ] = 0x83.
 * Итого, в сжатый файл пойдет: [ 0x83 0x01 ].
 *
 * Если старший бит = 0, то оставшиеся биты кодируют количество
 * одиночных элементов (байтов), следующих за прочитанным.
 * Пример: Исходные данные [ 0x01 0x02 0x03 0x04 ], Служебный байт =
 * [ 0 0 0 0  0 1 0 0 ], В файл [ 0x04 0x01 0x02 0x03 0x04 ].
 *
 * Как видно, если в исходном файле много не повторяющихся элементов, то
 * алгоритм отработает "в обратную" сторону.
 *
 * Максимальные размеры последовательностей ограничены 7-ю битами [0 - 127],
 * так что, если в последовательности больше 2^7  байт, она делится на
 * подпоследовательности.
 *
 * При последовательности ( одинаковых и неодинаковых элементов )невозможно
 * получить количество элементов, равное нулю. Отсюда, вместо [0-127] можно
 * увеличить [1-128], если при сжатии считать количество бит - 1, а при
 * декомпрессии + 1.
 *
 * Также не бывает последовательностей, состоящих из цепочки элементов, равной
 * длине 1. Соответственно, вместо уже [1-128] можно хранить [2-129]. Т.е.
 * инкрементировать/декрементировать на 2
 *
 * С новым условием, служебные байты в вышеизложенных примерах будут:
 * Пример 1: [ 1 0 0 0  0 0 0 1 ]
 * Пример 2: [ 0 0 0 0  0 0 1 1 ]
 *
 * Реализован с поиощью класса \ref cAlgorithmRLE
 * ****************************************************************************/


#ifndef CALGORITHMRLE_H
#define CALGORITHMRLE_H

#include "algorithm/cAbstractAlgorithm/h/cAbstractAlgorithm.h" /// Интерфейс алгоритмов

/// \brief Класс реализующий алгоритм RLE
/// \class cAlgorithmRLE
class cAlgorithmRLE final : public cAbstractAlgorithm
{
public:
    /// \brief Сжатие данных
    /// \param [in] oldData Исходные данные для сжатия
    /// \return Сжатые в соответсвии с алгоритмом RLE
    virtual std::string compress( const std::string & oldData ) override;

    /// \brief Распаковка данных
    /// \param [in] oldData Исходные данные для распаковки
    /// \return Распакованные данные в соответсвии с алгоритмом RLE
    virtual std::string decompress( const std::string & oldData ) override;

    /// \brief Получить постфикс для файла
    /// \return Строка-расширение для упакованных данных
    inline virtual std::string getPostfix( void ) const override { return ".cmprRLE"; }

private:
    /// \brief Типы последовательностей в исходном наборе данных
    /// \enum eTypeOfSequence
    enum eTypeOfSequence
    {
        SEQ_TYPE_SINGLE = 0, ///< Один элемент
        SEQ_TYPE_SET = 0x80 ///< Цепочка элементов
    };

    /// \brief Максимальные размеры последовательностей
    /// \enum eMaxSequenceSize
    enum eMaxSequenceSize
    {
        MAX_SIZE_SINGLE = 128, ///< Для SEQ_TYPE_SINGLE
        MAX_SIZE_SET = 129 ///< Для SEQ_TYPE_SET
    };

    /// \brief Инкремент для текущего размера последовательности
    /// \enum eCountIncrement
    enum eCountIncrement
    {
        COUNT_INCREMENT_SINGLE = 1, ///< Для SEQ_TYPE_SINGLE
        COUNT_INCREMENT_SET = 2 ///< Для SEQ_TYPE_SET
    };

    /// \brief Структура, описывающая служебный байт
    /// \struct sServiceByteInfo
    struct sServiceByteInfo
    {
        /// \brief Тип последовательности
        eTypeOfSequence mType;
        /// \brief Количество элементов в последовательности
        size_t mCount;
    };

    /// \brief Создать служебный байт для записи в сжатый набор данных
    ///
    /// \param [in] type Тип последовательности
    /// \param [in] count Тип последовательности
    ///
    /// \return Служебный байт
    static inline char getServiceByte( eTypeOfSequence type, symbol_t count ) noexcept
    {
        return ( SEQ_TYPE_SET == type ? count - 2 : count - 1 ) | type;
    }

    /// \brief Прочитать служебный байт из сжатого набора
    ///
    /// \param data [in] Сжатый набор данных
    /// \param index [in] Индекс служебного байта в наборе
    ///
    /// \return Структура, описывающая служебный байт
    static sServiceByteInfo readServiceByte(const char data[], size_t index ) noexcept;
};

/// @}


#endif // CALGORITHMRLE_H
